# Budget Request Creation Microservice - Backend Development Guide

## 🎯 Executive Summary

This guide provides a comprehensive approach to building the **Budget Request Creation Microservice** backend, optimized for performance, security, and seamless integration with the Finance Main system and Audit Logs.

---

## 📁 Project Structure

```
budget-request-microservice/
├── src/
│   ├── index.ts                          # Application entry point
│   ├── app.ts                            # Express app configuration
│   ├── server.ts                         # HTTP server setup
│   │
│   ├── config/
│   │   ├── database.ts                   # Prisma client singleton
│   │   ├── redis.ts                      # Redis client configuration
│   │   ├── constants.ts                  # App-wide constants
│   │   └── env.ts                        # Environment validation
│   │
│   ├── routes/
│   │   ├── index.ts                      # Route aggregator
│   │   ├── budgetRequest.routes.ts       # Budget request endpoints
│   │   ├── itemAllocation.routes.ts      # Item-level allocation endpoints
│   │   ├── approvalHistory.routes.ts     # Approval workflow endpoints
│   │   ├── sync.routes.ts                # Finance data sync endpoints
│   │   └── health.routes.ts              # Health check endpoint
│   │
│   ├── controllers/
│   │   ├── budgetRequest.controller.ts   # Main BR operations
│   │   ├── itemAllocation.controller.ts  # Item allocation logic
│   │   ├── approval.controller.ts        # Approval workflow
│   │   ├── sync.controller.ts            # External sync operations
│   │   └── analytics.controller.ts       # Dashboard & reporting
│   │
│   ├── services/
│   │   ├── budgetRequest.service.ts      # Core BR business logic
│   │   ├── itemAllocation.service.ts     # Item-level allocation
│   │   ├── approval.service.ts           # Approval workflow
│   │   ├── notification.service.ts       # Email/notification dispatch
│   │   ├── sync.service.ts               # External API sync
│   │   ├── cache.service.ts              # Redis caching layer
│   │   ├── webhook.service.ts            # Webhook event dispatch
│   │   └── auditLogger.service.ts        # Audit Logs integration
│   │
│   ├── middlewares/
│   │   ├── auth.middleware.ts            # JWT verification
│   │   ├── apiKey.middleware.ts          # API key validation
│   │   ├── roleAccess.middleware.ts      # Role-based access control
│   │   ├── validation.middleware.ts      # Request validation
│   │   ├── rateLimit.middleware.ts       # Rate limiting
│   │   ├── cache.middleware.ts           # Response caching
│   │   ├── errorHandler.middleware.ts    # Global error handling
│   │   └── requestLogger.middleware.ts   # Request/response logging
│   │
│   ├── utils/
│   │   ├── jwt.util.ts                   # JWT encode/decode
│   │   ├── hash.util.ts                  # API key hashing
│   │   ├── response.util.ts              # Standardized responses
│   │   ├── validation.util.ts            # Input validators
│   │   ├── calculator.util.ts            # Budget calculations
│   │   └── formatter.util.ts             # Data formatters
│   │
│   ├── types/
│   │   ├── express.d.ts                  # Express type extensions
│   │   ├── budgetRequest.d.ts            # BR type definitions
│   │   └── api.d.ts                      # API response types
│   │
│   ├── webhooks/
│   │   ├── handlers.ts                   # Webhook event handlers
│   │   ├── dispatcher.ts                 # Webhook dispatch logic
│   │   └── registry.ts                   # Webhook subscription registry
│   │
│   └── scripts/
│       ├── seed.ts                       # Database seeding
│       ├── migrate.ts                    # Migration runner
│       └── generateApiKeys.ts            # API key generator
│
├── prisma/
│   ├── schema.prisma                     # Database schema
│   ├── migrations/                       # Migration history
│   └── seed.ts                           # Seed script
│
├── tests/
│   ├── unit/                             # Unit tests
│   ├── integration/                      # Integration tests
│   └── e2e/                              # End-to-end tests
│
├── docs/
│   ├── API.md                            # API documentation
│   ├── INTEGRATION.md                    # Integration guide
│   └── DEPLOYMENT.md                     # Deployment guide
│
├── .env.example                          # Environment template
├── tsconfig.json                         # TypeScript config
├── package.json                          # Dependencies
└── README.md                             # Project overview
```

---

## 🔐 Authentication & Authorization

### JWT Token Structure

```typescript
// JWT Payload (issued by HR Auth Microservice)
interface JWTPayload {
  sub: string;        // User ID
  username: string;   // Username
  role: string;       // "Finance Admin", "Inventory Admin", etc.
  iat: number;        // Issued at
  exp: number;        // Expiration
}

// Extracted User Context
interface UserContext {
  id: string;
  username: string;
  role: string;
  department: string; // Extracted from role or API key
}
```

### Authentication Middleware

```typescript
// src/middlewares/auth.middleware.ts
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

const JWT_SECRET = process.env.JWT_SECRET || '8f7b3a2c9d4e6f8a0b1c2d3e4f5g6h7i';

export const verifyJWT = (req: Request, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'Authorization token required',
        code: 'MISSING_TOKEN'
      });
    }

    const token = authHeader.substring(7);
    const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;

    // Attach user context to request
    req.user = {
      id: decoded.sub,
      username: decoded.username,
      role: decoded.role,
      department: extractDepartment(decoded.role)
    };

    next();
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      return res.status(401).json({
        success: false,
        message: 'Token expired',
        code: 'TOKEN_EXPIRED'
      });
    }

    return res.status(401).json({
      success: false,
      message: 'Invalid token',
      code: 'INVALID_TOKEN'
    });
  }
};

function extractDepartment(role: string): string {
  // "Finance Admin" → "finance"
  // "Inventory Staff" → "inventory"
  const match = role.match(/^(Finance|HR|Inventory|Operations)/i);
  return match ? match[1].toLowerCase() : 'unknown';
}
```

### API Key Middleware

```typescript
// src/middlewares/apiKey.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { prisma } from '../config/database';
import crypto from 'crypto';

export const verifyApiKey = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const apiKey = req.headers['x-api-key'] as string;

    if (!apiKey) {
      return res.status(401).json({
        success: false,
        message: 'API key required',
        code: 'MISSING_API_KEY'
      });
    }

    // Hash the provided key
    const hashedKey = crypto
      .createHash('sha256')
      .update(apiKey)
      .digest('hex');

    // Validate against database
    const validKey = await prisma.apiKey.findUnique({
      where: { keyHash: hashedKey }
    });

    if (!validKey || !validKey.isActive) {
      return res.status(401).json({
        success: false,
        message: 'Invalid or inactive API key',
        code: 'INVALID_API_KEY'
      });
    }

    // Check expiration
    if (validKey.expiresAt && validKey.expiresAt < new Date()) {
      return res.status(401).json({
        success: false,
        message: 'API key expired',
        code: 'EXPIRED_API_KEY'
      });
    }

    // Update last used timestamp
    await prisma.apiKey.update({
      where: { id: validKey.id },
      data: { lastUsedAt: new Date() }
    });

    // Attach service context
    req.serviceName = validKey.serviceName;
    req.apiKeyId = validKey.id;

    next();
  } catch (error) {
    return res.status(500).json({
      success: false,
      message: 'API key validation failed',
      code: 'API_KEY_ERROR'
    });
  }
};
```

### Role-Based Access Control

```typescript
// src/middlewares/roleAccess.middleware.ts
import { Request, Response, NextFunction } from 'express';

type RoleLevel = 'superadmin' | 'admin' | 'user';

export const requireRole = (...allowedRoles: RoleLevel[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRole = determineRoleLevel(req.user.role);

    if (!allowedRoles.includes(userRole)) {
      return res.status(403).json({
        success: false,
        message: 'Insufficient permissions',
        code: 'FORBIDDEN'
      });
    }

    next();
  };
};

function determineRoleLevel(role: string): RoleLevel {
  if (role === 'SuperAdmin') return 'superadmin';
  if (role.includes('Admin')) return 'admin';
  return 'user';
}

// Apply access filter to queries
export function applyAccessFilter(
  baseQuery: any,
  user: UserContext,
  serviceName?: string
): any {
  const roleLevel = determineRoleLevel(user.role);

  // SuperAdmin: No restrictions
  if (roleLevel === 'superadmin') {
    return baseQuery;
  }

  // Department Admin: Own department only
  if (roleLevel === 'admin') {
    return {
      ...baseQuery,
      department: serviceName || user.department
    };
  }

  // Regular User: Own records only
  return {
    ...baseQuery,
    requestedBy: user.id
  };
}
```

---

## 🗄️ Database Optimization

### Prisma Client Configuration

```typescript
// src/config/database.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' 
      ? ['query', 'info', 'warn', 'error']
      : ['error'],
    datasources: {
      db: {
        url: process.env.BUDGET_REQUEST_DATABASE_URL
      }
    }
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Graceful shutdown
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});
```

### Critical Indexes (Already in Schema)

The schema already includes optimized indexes:

```prisma
// BudgetRequest indexes
@@index([department, status])
@@index([requestedBy, createdAt])
@@index([status, createdAt])
@@index([linkedPurchaseRequestId])
@@index([fiscalYear, fiscalPeriod])
@@index([isReserved, reservationExpiry])
@@index([isOverdue, slaDeadline])
@@index([priority, status])

// ItemAllocation indexes
@@index([budgetRequestId])
@@index([status])
@@index([supplierId])
@@index([isEssential, itemPriority])

// CachedDepartmentBudget indexes
@@index([department, fiscalYear, fiscalPeriod])
@@index([lastSyncedAt])
@@index([isStale])
```

### Query Optimization Patterns

```typescript
// src/services/budgetRequest.service.ts

// ✅ GOOD: Use select to fetch only needed fields
async function getBudgetRequestSummary(id: number) {
  return prisma.budgetRequest.findUnique({
    where: { id },
    select: {
      id: true,
      requestCode: true,
      department: true,
      amountRequested: true,
      status: true,
      createdAt: true
    }
  });
}

// ✅ GOOD: Use cursor-based pagination for large datasets
async function listBudgetRequests(cursor?: number, limit = 20) {
  return prisma.budgetRequest.findMany({
    take: limit,
    skip: cursor ? 1 : 0,
    cursor: cursor ? { id: cursor } : undefined,
    orderBy: { createdAt: 'desc' }
  });
}

// ✅ GOOD: Batch operations with transactions
async function approveBulkRequests(ids: number[], approverInfo: any) {
  return prisma.$transaction(
    ids.map(id =>
      prisma.budgetRequest.update({
        where: { id },
        data: {
          status: 'APPROVED',
          reviewedBy: approverInfo.userId,
          reviewedAt: new Date()
        }
      })
    )
  );
}
```

---

## 🚀 Redis Caching Strategy

### Redis Configuration

```typescript
// src/config/redis.ts
import Redis from 'ioredis';

const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  db: parseInt(process.env.REDIS_DB || '0'),
  retryStrategy: (times) => {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
  maxRetriesPerRequest: 3
});

redis.on('error', (err) => {
  console.error('Redis connection error:', err);
});

redis.on('connect', () => {
  console.log('✅ Redis connected');
});

export default redis;
```

### Cache Service

```typescript
// src/services/cache.service.ts
import redis from '../config/redis';

class CacheService {
  // Cache department budget data (15 min TTL)
  async cacheDepartmentBudget(department: string, fiscalPeriod: string, data: any) {
    const key = `budget:${department}:${fiscalPeriod}`;
    await redis.setex(key, 900, JSON.stringify(data)); // 15 minutes
  }

  async getDepartmentBudget(department: string, fiscalPeriod: string) {
    const key = `budget:${department}:${fiscalPeriod}`;
    const cached = await redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // Cache budget request details (5 min TTL)
  async cacheBudgetRequest(id: number, data: any) {
    const key = `br:${id}`;
    await redis.setex(key, 300, JSON.stringify(data)); // 5 minutes
  }

  async getBudgetRequest(id: number) {
    const key = `br:${id}`;
    const cached = await redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // Invalidate cache
  async invalidateBudgetRequest(id: number) {
    await redis.del(`br:${id}`);
  }

  async invalidateDepartmentBudget(department: string, fiscalPeriod: string) {
    await redis.del(`budget:${department}:${fiscalPeriod}`);
  }

  // Cache user permissions (1 hour TTL)
  async cacheUserPermissions(userId: string, permissions: any) {
    const key = `perm:${userId}`;
    await redis.setex(key, 3600, JSON.stringify(permissions));
  }

  async getUserPermissions(userId: string) {
    const key = `perm:${userId}`;
    const cached = await redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }
}

export default new CacheService();
```

### Cache Middleware

```typescript
// src/middlewares/cache.middleware.ts
import { Request, Response, NextFunction } from 'express';
import redis from '../config/redis';

export const cacheResponse = (ttl: number = 300) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    // Only cache GET requests
    if (req.method !== 'GET') {
      return next();
    }

    const cacheKey = `route:${req.originalUrl}:${req.user?.id || 'anon'}`;

    try {
      const cached = await redis.get(cacheKey);
      
      if (cached) {
        return res.status(200).json({
          ...JSON.parse(cached),
          _cached: true
        });
      }

      // Override res.json to cache response
      const originalJson = res.json.bind(res);
      res.json = (body: any) => {
        redis.setex(cacheKey, ttl, JSON.stringify(body));
        return originalJson(body);
      };

      next();
    } catch (error) {
      // If cache fails, continue without caching
      next();
    }
  };
};
```

---

## 📡 Webhook System

### Webhook Event Types

```typescript
// src/types/webhook.d.ts
export type WebhookEvent =
  | 'budget_request.created'
  | 'budget_request.submitted'
  | 'budget_request.approved'
  | 'budget_request.rejected'
  | 'budget_request.cancelled'
  | 'item_allocation.approved'
  | 'item_allocation.modified'
  | 'reservation.expired';

export interface WebhookPayload {
  event: WebhookEvent;
  timestamp: string;
  data: {
    budgetRequestId: number;
    requestCode: string;
    department: string;
    [key: string]: any;
  };
}
```

### Webhook Dispatcher

```typescript
// src/webhooks/dispatcher.ts
import axios from 'axios';
import { prisma } from '../config/database';

class WebhookDispatcher {
  async dispatch(event: WebhookEvent, data: any) {
    // Get subscribed endpoints from SystemConfig or database
    const webhooks = await this.getWebhookSubscriptions(event);

    const payload: WebhookPayload = {
      event,
      timestamp: new Date().toISOString(),
      data
    };

    // Dispatch to all subscribers
    const promises = webhooks.map(webhook =>
      this.sendWebhook(webhook.url, payload, webhook.secret)
    );

    await Promise.allSettled(promises);
  }

  private async sendWebhook(url: string, payload: WebhookPayload, secret?: string) {
    try {
      const headers: any = {
        'Content-Type': 'application/json',
        'X-Webhook-Event': payload.event,
        'X-Webhook-Timestamp': payload.timestamp
      };

      if (secret) {
        // Add HMAC signature for verification
        const crypto = require('crypto');
        const signature = crypto
          .createHmac('sha256', secret)
          .update(JSON.stringify(payload))
          .digest('hex');
        headers['X-Webhook-Signature'] = signature;
      }

      await axios.post(url, payload, { headers, timeout: 5000 });
    } catch (error) {
      console.error(`Webhook failed for ${url}:`, error);
      // Log failure for retry later
    }
  }

  private async getWebhookSubscriptions(event: WebhookEvent) {
    // Retrieve from SystemConfig or separate WebhookSubscription table
    const config = await prisma.systemConfig.findUnique({
      where: { configKey: `webhook_subscriptions_${event}` }
    });

    return config ? JSON.parse(config.configValue) : [];
  }
}

export default new WebhookDispatcher();
```

### Webhook Usage in Service

```typescript
// src/services/budgetRequest.service.ts
import webhookDispatcher from '../webhooks/dispatcher';

async function approveBudgetRequest(id: number, approverInfo: any) {
  const budgetRequest = await prisma.budgetRequest.update({
    where: { id },
    data: {
      status: 'APPROVED',
      reviewedBy: approverInfo.userId,
      reviewedAt: new Date()
    }
  });

  // Dispatch webhook event
  await webhookDispatcher.dispatch('budget_request.approved', {
    budgetRequestId: budgetRequest.id,
    requestCode: budgetRequest.requestCode,
    department: budgetRequest.department,
    amountRequested: budgetRequest.amountRequested,
    approvedBy: approverInfo.userId
  });

  return budgetRequest;
}
```

---

## 🔗 Integration with Finance Main & Audit Logs

### Audit Logger Service

```typescript
// src/services/auditLogger.service.ts
import axios from 'axios';

const AUDIT_LOGS_API_URL = process.env.AUDIT_LOGS_API_URL || 'http://localhost:4004';
const AUDIT_API_KEY = process.env.AUDIT_API_KEY || 'FINANCE_DEFAULT_KEY';

class AuditLoggerService {
  async log(action: string, data: any, user: any) {
    try {
      const payload = {
        moduleName: 'Budget Request',
        recordId: data.id?.toString(),
        recordCode: data.requestCode,
        action,
        performedBy: user.id,
        performedByName: user.username,
        performedByRole: user.role,
        oldValues: data.oldValues ? JSON.stringify(data.oldValues) : null,
        newValues: data.newValues ? JSON.stringify(data.newValues) : null,
        changedFields: data.changedFields ? JSON.stringify(data.changedFields) : null,
        reason: data.reason,
        metadata: data.metadata ? JSON.stringify(data.metadata) : null
      };

      await axios.post(`${AUDIT_LOGS_API_URL}/api/audit-logs`, payload, {
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': AUDIT_API_KEY
        },
        timeout: 5000
      });
    } catch (error) {
      // Don't break main flow if audit logging fails
      console.error('Audit logging failed:', error);
    }
  }

  // Convenience methods
  create(data: any, user: any) {
    return this.log('CREATE', { newValues: data, ...data }, user);
  }

  update(id: number, oldData: any, newData: any, user: any) {
    return this.log('UPDATE', {
      id,
      oldValues: oldData,
      newValues: newData,
      changedFields: Object.keys(newData)
    }, user);
  }

  delete(id: number, data: any, user: any) {
    return this.log('DELETE', { id, oldValues: data }, user);
  }

  approve(data: any, user: any) {
    return this.log('APPROVE', data, user);
  }

  reject(data: any, user: any) {
    return this.log('REJECT', data, user);
  }
}

export default new AuditLoggerService();
```

### Finance Sync Service

```typescript
// src/services/sync.service.ts
import axios from 'axios';
import { prisma } from '../config/database';
import cacheService from './cache.service';

const FINANCE_API_URL = process.env.FINANCE_API_URL || 'http://localhost:4001';
const FINANCE_API_KEY = process.env.FINANCE_API_KEY;

class SyncService {
  // Sync department budget from Finance Main
  async syncDepartmentBudget(department: string, fiscalYear: number, fiscalPeriod: string) {
    try {
      const response = await axios.get(
        `${FINANCE_API_URL}/api/budgets/${department}/${fiscalYear}/${fiscalPeriod}`,
        {
          headers: { 'x-api-key': FINANCE_API_KEY },
          timeout: 10000
        }
      );

      const budgetData = response.data.data;

      // Upsert to local cache table
      await prisma.cachedDepartmentBudget.upsert({
        where: {
          department_fiscalYear_fiscalPeriod: {
            department,
            fiscalYear,
            fiscalPeriod
          }
        },
        create: {
          budgetId: budgetData.id,
          department,
          fiscalYear,
          fiscalPeriod,
          allocatedAmount: budgetData.allocatedAmount,
          usedAmount: budgetData.usedAmount,
          reservedAmount: budgetData.reservedAmount,
          remainingAmount: budgetData.remainingAmount,
          periodStart: budgetData.periodStart,
          periodEnd: budgetData.periodEnd,
          lastSyncedAt: new Date(),
          isStale: false
        },
        update: {
          allocatedAmount: budgetData.allocatedAmount,
          usedAmount: budgetData.usedAmount,
          reservedAmount: budgetData.reservedAmount,
          remainingAmount: budgetData.remainingAmount,
          lastSyncedAt: new Date(),
          isStale: false
        }
      });

      // Update Redis cache
      await cacheService.cacheDepartmentBudget(department, fiscalPeriod, budgetData);

      return budgetData;
    } catch (error) {
      console.error('Finance sync failed:', error);
      
      // Mark cache as stale
      await prisma.cachedDepartmentBudget.updateMany({
        where: { department, fiscalYear, fiscalPeriod },
        data: { isStale: true }
      });

      throw error;
    }
  }

  // Notify Finance Main of budget reservation
  async notifyBudgetReservation(budgetRequestId: number) {
    try {
      const budgetRequest = await prisma.budgetRequest.findUnique({
        where: { id: budgetRequestId }
      });

      if (!budgetRequest) return;

      await axios.post(
        `${FINANCE_API_URL}/api/budgets/reserve`,
        {
          department: budgetRequest.department,
          fiscalYear: budgetRequest.fiscalYear,
          fiscalPeriod: budgetRequest.fiscalPeriod,
          amount: budgetRequest.reservedAmount,
          budgetRequestId,
          budgetRequestCode: budgetRequest.requestCode
        },
        {
          headers: { 'x-api-key': FINANCE_API_KEY },
          timeout: 10000
        }
      );
    } catch (error) {
      console.error('Budget reservation notification failed:', error);
    }
  }
}

export default new SyncService();
```

---

## 🛣️ API Routes Example

```typescript
// src/routes/budgetRequest.routes.ts
import express from 'express';
import { verifyJWT } from '../middlewares/auth.middleware';
import { requireRole } from '../middlewares/roleAccess.middleware';
import { cacheResponse } from '../middlewares/cache.middleware';
import * as controller from '../controllers/budgetRequest.controller';

const router = express.Router();

// All routes require JWT authentication
router.use(verifyJWT);

// List budget requests (cached for 5 minutes)
router.get(
  '/',
  cacheResponse(300),
  controller.listBudgetRequests
);

// Get single budget request
router.get('/:id', controller.getBudgetRequest);

// Create new budget request
router.post(
  '/',
  requireRole('admin', 'user'),
  controller.createBudgetRequest
);

// Update budget request (draft only)
router.put(
  '/:id',
  requireRole('admin', 'user'),
  controller.updateBudgetRequest
);

// Submit budget request for approval
router.post(
  '/:id/submit',
  requireRole('admin', 'user'),
  controller.submitBudgetRequest
);

// Approve budget request (admin only)
router.post(
  '/:id/approve',
  requireRole('admin', 'superadmin'),
  controller.approveBudgetRequest
);

// Reject budget request (admin only)
router.post(
  '/:id/reject',
  requireRole('admin', 'superadmin'),
  controller.rejectBudgetRequest
);

// Cancel budget request
router.post(
  '/:id/cancel',
  requireRole('admin', 'user'),
  controller.cancelBudgetRequest
);

export default router;
```

---

## 🌍 Environment Variables

```bash
# .env
# Server Configuration
PORT=4005
NODE_ENV=development
SERVICE_NAME=budget-request-microservice

# Database
BUDGET_REQUEST_DATABASE_URL=postgresql://postgres:password@localhost:5432/budget_request_db?schema=public
SHADOW_DATABASE_URL=postgresql://postgres:password@localhost:5432/budget_request_shadow_db?schema=public

# Redis Cache
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=1

# JWT Authentication
JWT_SECRET=8f7b3a2c9d4e6f8a0b1c2d3e4f5g6h7i

# External Services
FINANCE_API_URL=http://localhost:4001
FINANCE_API_KEY=FINANCE_SERVICE_KEY

AUDIT_LOGS_API_URL=http://localhost:4004
AUDIT_API_KEY=FINANCE_DEFAULT_KEY

# Webhook Configuration
WEBHOOK_SECRET=your_webhook_signing_secret

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000  # 15 minutes
RATE_LIMIT_MAX_REQUESTS=100

# CORS
CORS_ORIGIN=http://localhost:3000
```

---

## 📊 Performance Optimizations Summary

### Database
- ✅ Optimized indexes on all frequently queried fields
- ✅ Use `select` to fetch only needed fields
- ✅ Cursor-based pagination for large datasets
- ✅ Batch operations with transactions

### Caching
- ✅ Redis for department budget data (15 min TTL)
- ✅ Redis for budget request details (5 min TTL)
- ✅ Redis for user permissions (1 hour TTL)
- ✅ Response caching middleware for GET endpoints

## 📊 Performance Optimizations Summary (continued)

### API Design (continued)
- ✅ Async operations for non-critical tasks (audit logs, webhooks)
- ✅ Graceful degradation when external services fail
- ✅ Connection pooling for database and Redis
- ✅ Request/response compression

### Code Optimization
```typescript
// src/utils/calculator.util.ts
export class BudgetCalculator {
  // Calculate budget utilization metrics
  static calculateUtilization(budget: CachedDepartmentBudget) {
    const utilizationRate = 
      ((budget.usedAmount + budget.reservedAmount) / budget.allocatedAmount) * 100;
    
    const availableRate = 
      (budget.remainingAmount / budget.allocatedAmount) * 100;
    
    const burnRate = 
      budget.usedAmount / this.getDaysPassed(budget.periodStart);
    
    const projectedDepletion = this.calculateDepletion(
      budget.remainingAmount,
      burnRate
    );

    return {
      utilizationRate: Number(utilizationRate.toFixed(2)),
      availableRate: Number(availableRate.toFixed(2)),
      burnRate: Number(burnRate.toFixed(2)),
      projectedDepletion,
      isOverBudget: budget.remainingAmount < 0,
      isNearingLimit: utilizationRate > 80
    };
  }

  private static getDaysPassed(startDate: Date): number {
    const now = new Date();
    const diff = now.getTime() - new Date(startDate).getTime();
    return Math.max(1, Math.floor(diff / (1000 * 60 * 60 * 24)));
  }

  private static calculateDepletion(remaining: number, dailyBurn: number): Date | null {
    if (dailyBurn <= 0 || remaining <= 0) return null;
    const daysRemaining = remaining / dailyBurn;
    const depletionDate = new Date();
    depletionDate.setDate(depletionDate.getDate() + Math.floor(daysRemaining));
    return depletionDate;
  }
}
```

---

## 🎯 Core Controller Implementation

```typescript
// src/controllers/budgetRequest.controller.ts
import { Request, Response } from 'express';
import * as service from '../services/budgetRequest.service';
import auditLogger from '../services/auditLogger.service';
import webhookDispatcher from '../webhooks/dispatcher';
import { applyAccessFilter } from '../middlewares/roleAccess.middleware';

export async function listBudgetRequests(req: Request, res: Response) {
  try {
    const { 
      page = 1, 
      limit = 20, 
      status, 
      department,
      dateFrom,
      dateTo,
      priority 
    } = req.query;

    // Build base filter
    let filter: any = {
      isDeleted: false
    };

    // Apply status filter
    if (status) filter.status = status;

    // Apply department filter
    if (department) filter.department = department;

    // Apply date range filter
    if (dateFrom || dateTo) {
      filter.createdAt = {};
      if (dateFrom) filter.createdAt.gte = new Date(dateFrom as string);
      if (dateTo) filter.createdAt.lte = new Date(dateTo as string);
    }

    // Apply priority filter
    if (priority) filter.priority = priority;

    // Apply role-based access control
    filter = applyAccessFilter(filter, req.user, req.serviceName);

    // Execute query with pagination
    const skip = (Number(page) - 1) * Number(limit);
    const [data, total] = await Promise.all([
      service.findMany(filter, {
        skip,
        take: Number(limit),
        orderBy: { createdAt: 'desc' },
        include: {
          itemAllocations: {
            select: {
              id: true,
              itemName: true,
              allocatedAmount: true,
              status: true
            }
          }
        }
      }),
      service.count(filter)
    ]);

    res.json({
      success: true,
      message: 'Budget requests retrieved successfully',
      data,
      meta: {
        page: Number(page),
        limit: Number(limit),
        total,
        totalPages: Math.ceil(total / Number(limit))
      }
    });
  } catch (error) {
    console.error('List budget requests error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to retrieve budget requests',
      error: error.message
    });
  }
}

export async function getBudgetRequest(req: Request, res: Response) {
  try {
    const { id } = req.params;

    const budgetRequest = await service.findById(Number(id), {
      include: {
        itemAllocations: true,
        approvalHistory: {
          orderBy: { changedAt: 'desc' },
          take: 10
        },
        notifications: {
          orderBy: { sentAt: 'desc' },
          take: 5
        }
      }
    });

    if (!budgetRequest) {
      return res.status(404).json({
        success: false,
        message: 'Budget request not found',
        code: 'NOT_FOUND'
      });
    }

    // Verify access rights
    const hasAccess = service.checkAccess(budgetRequest, req.user);
    if (!hasAccess) {
      return res.status(403).json({
        success: false,
        message: 'Access denied',
        code: 'FORBIDDEN'
      });
    }

    // Log view action
    await auditLogger.log('VIEW', {
      id: budgetRequest.id,
      requestCode: budgetRequest.requestCode
    }, req.user);

    res.json({
      success: true,
      message: 'Budget request retrieved successfully',
      data: budgetRequest
    });
  } catch (error) {
    console.error('Get budget request error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to retrieve budget request',
      error: error.message
    });
  }
}

export async function createBudgetRequest(req: Request, res: Response) {
  try {
    const {
      department,
      amountRequested,
      purpose,
      justification,
      category,
      priority,
      items,
      linkedPurchaseRequestId,
      linkedPurchaseRequestRefNo
    } = req.body;

    // Validate required fields
    if (!department || !amountRequested || !purpose) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields',
        code: 'VALIDATION_ERROR'
      });
    }

    // Create budget request with items
    const budgetRequest = await service.create({
      department,
      amountRequested,
      purpose,
      justification,
      category,
      priority,
      requestedBy: req.user.id,
      requestedByName: req.user.username,
      requestedByRole: req.user.role,
      linkedPurchaseRequestId,
      linkedPurchaseRequestRefNo,
      items: items || []
    });

    // Log creation
    await auditLogger.create({
      id: budgetRequest.id,
      requestCode: budgetRequest.requestCode,
      department,
      amountRequested
    }, req.user);

    // Dispatch webhook
    await webhookDispatcher.dispatch('budget_request.created', {
      budgetRequestId: budgetRequest.id,
      requestCode: budgetRequest.requestCode,
      department,
      amountRequested
    });

    res.status(201).json({
      success: true,
      message: 'Budget request created successfully',
      data: budgetRequest
    });
  } catch (error) {
    console.error('Create budget request error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create budget request',
      error: error.message
    });
  }
}

export async function submitBudgetRequest(req: Request, res: Response) {
  try {
    const { id } = req.params;

    // Get existing budget request
    const existing = await service.findById(Number(id));
    
    if (!existing) {
      return res.status(404).json({
        success: false,
        message: 'Budget request not found',
        code: 'NOT_FOUND'
      });
    }

    // Verify ownership or admin role
    if (existing.requestedBy !== req.user.id && !req.user.role.includes('Admin')) {
      return res.status(403).json({
        success: false,
        message: 'Access denied',
        code: 'FORBIDDEN'
      });
    }

    // Can only submit drafts
    if (existing.status !== 'PENDING' || !existing.isDraft) {
      return res.status(400).json({
        success: false,
        message: 'Only draft budget requests can be submitted',
        code: 'INVALID_STATUS'
      });
    }

    // Submit (change isDraft to false)
    const updated = await service.submit(Number(id));

    // Log submission
    await auditLogger.log('SUBMIT', {
      id: updated.id,
      requestCode: updated.requestCode,
      oldValues: { isDraft: true, status: 'PENDING' },
      newValues: { isDraft: false, status: 'PENDING' }
    }, req.user);

    // Dispatch webhook
    await webhookDispatcher.dispatch('budget_request.submitted', {
      budgetRequestId: updated.id,
      requestCode: updated.requestCode,
      department: updated.department,
      amountRequested: updated.amountRequested,
      requestedBy: updated.requestedBy
    });

    res.json({
      success: true,
      message: 'Budget request submitted successfully',
      data: updated
    });
  } catch (error) {
    console.error('Submit budget request error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to submit budget request',
      error: error.message
    });
  }
}

export async function approveBudgetRequest(req: Request, res: Response) {
  try {
    const { id } = req.params;
    const { reviewNotes, reservedAmount, bufferPercentage } = req.body;

    // Get existing budget request
    const existing = await service.findById(Number(id));
    
    if (!existing) {
      return res.status(404).json({
        success: false,
        message: 'Budget request not found',
        code: 'NOT_FOUND'
      });
    }

    // Verify admin role
    if (!req.user.role.includes('Admin')) {
      return res.status(403).json({
        success: false,
        message: 'Only admins can approve budget requests',
        code: 'FORBIDDEN'
      });
    }

    // Can only approve pending requests
    if (existing.status !== 'PENDING') {
      return res.status(400).json({
        success: false,
        message: 'Only pending budget requests can be approved',
        code: 'INVALID_STATUS'
      });
    }

    // Approve budget request
    const approved = await service.approve(Number(id), {
      reviewedBy: req.user.id,
      reviewedByName: req.user.username,
      reviewNotes,
      reservedAmount,
      bufferPercentage
    });

    // Log approval
    await auditLogger.approve({
      id: approved.id,
      requestCode: approved.requestCode,
      oldValues: { status: 'PENDING' },
      newValues: { 
        status: 'APPROVED',
        reviewedBy: req.user.id,
        reviewedAt: new Date()
      },
      reason: reviewNotes
    }, req.user);

    // Dispatch webhook
    await webhookDispatcher.dispatch('budget_request.approved', {
      budgetRequestId: approved.id,
      requestCode: approved.requestCode,
      department: approved.department,
      amountRequested: approved.amountRequested,
      reservedAmount: approved.reservedAmount,
      approvedBy: req.user.id
    });

    res.json({
      success: true,
      message: 'Budget request approved successfully',
      data: approved
    });
  } catch (error) {
    console.error('Approve budget request error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to approve budget request',
      error: error.message
    });
  }
}

export async function rejectBudgetRequest(req: Request, res: Response) {
  try {
    const { id } = req.params;
    const { reviewNotes } = req.body;

    if (!reviewNotes) {
      return res.status(400).json({
        success: false,
        message: 'Rejection reason is required',
        code: 'VALIDATION_ERROR'
      });
    }

    // Get existing budget request
    const existing = await service.findById(Number(id));
    
    if (!existing) {
      return res.status(404).json({
        success: false,
        message: 'Budget request not found',
        code: 'NOT_FOUND'
      });
    }

    // Verify admin role
    if (!req.user.role.includes('Admin')) {
      return res.status(403).json({
        success: false,
        message: 'Only admins can reject budget requests',
        code: 'FORBIDDEN'
      });
    }

    // Can only reject pending requests
    if (existing.status !== 'PENDING') {
      return res.status(400).json({
        success: false,
        message: 'Only pending budget requests can be rejected',
        code: 'INVALID_STATUS'
      });
    }

    // Reject budget request
    const rejected = await service.reject(Number(id), {
      reviewedBy: req.user.id,
      reviewedByName: req.user.username,
      reviewNotes
    });

    // Log rejection
    await auditLogger.reject({
      id: rejected.id,
      requestCode: rejected.requestCode,
      oldValues: { status: 'PENDING' },
      newValues: { 
        status: 'REJECTED',
        reviewedBy: req.user.id,
        rejectedAt: new Date()
      },
      reason: reviewNotes
    }, req.user);

    // Dispatch webhook
    await webhookDispatcher.dispatch('budget_request.rejected', {
      budgetRequestId: rejected.id,
      requestCode: rejected.requestCode,
      department: rejected.department,
      amountRequested: rejected.amountRequested,
      rejectedBy: req.user.id,
      reason: reviewNotes
    });

    res.json({
      success: true,
      message: 'Budget request rejected successfully',
      data: rejected
    });
  } catch (error) {
    console.error('Reject budget request error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to reject budget request',
      error: error.message
    });
  }
}
```

---

## 🧩 Core Service Implementation

```typescript
// src/services/budgetRequest.service.ts
import { prisma } from '../config/database';
import cacheService from './cache.service';
import syncService from './sync.service';
import notificationService from './notification.service';

export async function findMany(filter: any, options: any = {}) {
  return prisma.budgetRequest.findMany({
    where: filter,
    ...options
  });
}

export async function count(filter: any) {
  return prisma.budgetRequest.count({ where: filter });
}

export async function findById(id: number, options: any = {}) {
  // Try cache first
  const cached = await cacheService.getBudgetRequest(id);
  if (cached) return cached;

  // Fetch from database
  const budgetRequest = await prisma.budgetRequest.findUnique({
    where: { id },
    ...options
  });

  // Cache result
  if (budgetRequest) {
    await cacheService.cacheBudgetRequest(id, budgetRequest);
  }

  return budgetRequest;
}

export async function create(data: any) {
  // Sync department budget from Finance
  const budget = await syncService.syncDepartmentBudget(
    data.department,
    new Date().getFullYear(),
    getCurrentFiscalPeriod()
  );

  // Calculate budget metrics
  const budgetShortfall = data.amountRequested - budget.remainingAmount;
  const requiresBudgetApproval = budgetShortfall > 0;

  // Create budget request with items in transaction
  const budgetRequest = await prisma.$transaction(async (tx) => {
    // Create main budget request
    const br = await tx.budgetRequest.create({
      data: {
        ...data,
        fiscalYear: new Date().getFullYear(),
        fiscalPeriod: getCurrentFiscalPeriod(),
        departmentBudgetRemaining: budget.remainingAmount,
        budgetShortfall: budgetShortfall > 0 ? budgetShortfall : null,
        budgetUtilizationBeforeRequest: budget.utilizationRate,
        requiresBudgetApproval,
        isDraft: true,
        status: 'PENDING'
      }
    });

    // Create item allocations if provided
    if (data.items && data.items.length > 0) {
      await tx.budgetRequestItemAllocation.createMany({
        data: data.items.map((item: any) => ({
          budgetRequestId: br.id,
          ...item,
          status: 'PENDING'
        }))
      });
    }

    return br;
  });

  return budgetRequest;
}

export async function submit(id: number) {
  const updated = await prisma.budgetRequest.update({
    where: { id },
    data: {
      isDraft: false,
      updatedAt: new Date()
    }
  });

  // Invalidate cache
  await cacheService.invalidateBudgetRequest(id);

  // Send notification to admins
  await notificationService.notifyAdminsNewRequest(updated);

  // Create approval history entry
  await prisma.budgetRequestApprovalHistory.create({
    data: {
      budgetRequestId: id,
      fromStatus: null,
      toStatus: 'PENDING',
      changedBy: updated.requestedBy,
      changedByName: updated.requestedByName,
      changedByRole: updated.requestedByRole,
      action: 'SUBMITTED',
      comments: 'Budget request submitted for review'
    }
  });

  return updated;
}

export async function approve(id: number, approvalData: any) {
  const bufferAmount = approvalData.bufferPercentage 
    ? (approvalData.reservedAmount || 0) * (approvalData.bufferPercentage / 100)
    : 0;

  const totalReserved = (approvalData.reservedAmount || 0) + bufferAmount;

  const approved = await prisma.$transaction(async (tx) => {
    // Update budget request
    const br = await tx.budgetRequest.update({
      where: { id },
      data: {
        status: 'APPROVED',
        reviewedBy: approvalData.reviewedBy,
        reviewedByName: approvalData.reviewedByName,
        reviewNotes: approvalData.reviewNotes,
        reviewedAt: new Date(),
        approvedBy: approvalData.reviewedBy,
        approvedAt: new Date(),
        reservedAmount: totalReserved,
        bufferAmount,
        bufferPercentage: approvalData.bufferPercentage,
        isReserved: true,
        reservedAt: new Date(),
        // Set expiry (e.g., 90 days from approval)
        reservationExpiry: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000)
      }
    });

    // Create approval history
    await tx.budgetRequestApprovalHistory.create({
      data: {
        budgetRequestId: id,
        fromStatus: 'PENDING',
        toStatus: 'APPROVED',
        changedBy: approvalData.reviewedBy,
        changedByName: approvalData.reviewedByName,
        action: 'APPROVED',
        comments: approvalData.reviewNotes
      }
    });

    return br;
  });

  // Invalidate cache
  await cacheService.invalidateBudgetRequest(id);

  // Notify Finance Main about reservation
  await syncService.notifyBudgetReservation(id);

  // Send approval notification
  await notificationService.notifyRequestApproved(approved);

  return approved;
}

export async function reject(id: number, rejectionData: any) {
  const rejected = await prisma.$transaction(async (tx) => {
    // Update budget request
    const br = await tx.budgetRequest.update({
      where: { id },
      data: {
        status: 'REJECTED',
        reviewedBy: rejectionData.reviewedBy,
        reviewedByName: rejectionData.reviewedByName,
        reviewNotes: rejectionData.reviewNotes,
        reviewedAt: new Date(),
        rejectedBy: rejectionData.reviewedBy,
        rejectedAt: new Date()
      }
    });

    // Create approval history
    await tx.budgetRequestApprovalHistory.create({
      data: {
        budgetRequestId: id,
        fromStatus: 'PENDING',
        toStatus: 'REJECTED',
        changedBy: rejectionData.reviewedBy,
        changedByName: rejectionData.reviewedByName,
        action: 'REJECTED',
        comments: rejectionData.reviewNotes
      }
    });

    return br;
  });

  // Invalidate cache
  await cacheService.invalidateBudgetRequest(id);

  // Send rejection notification
  await notificationService.notifyRequestRejected(rejected);

  return rejected;
}

export function checkAccess(budgetRequest: any, user: any): boolean {
  // SuperAdmin: full access
  if (user.role === 'SuperAdmin') return true;

  // Department Admin: own department only
  if (user.role.includes('Admin')) {
    return budgetRequest.department === user.department;
  }

  // Regular user: own requests only
  return budgetRequest.requestedBy === user.id;
}

function getCurrentFiscalPeriod(): string {
  const now = new Date();
  const month = now.getMonth() + 1;
  const quarter = Math.ceil(month / 3);
  return `Q${quarter}`;
}
```

---

## 📧 Notification Service

```typescript
// src/services/notification.service.ts
import { prisma } from '../config/database';
import nodemailer from 'nodemailer';

const transporter = nodemailer.createTransporter({
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASSWORD
  }
});

class NotificationService {
  async notifyAdminsNewRequest(budgetRequest: any) {
    const subject = `New Budget Request: ${budgetRequest.requestCode}`;
    const message = `
      A new budget request has been submitted:
      
      Request Code: ${budgetRequest.requestCode}
      Department: ${budgetRequest.department}
      Amount: ${budgetRequest.amountRequested}
      Requested By: ${budgetRequest.requestedByName}
      Purpose: ${budgetRequest.purpose}
      
      Please review at: ${process.env.FRONTEND_URL}/budget-requests/${budgetRequest.id}
    `;

    // Get department admins
    const admins = await this.getDepartmentAdmins(budgetRequest.department);

    // Send notifications
    await Promise.all(
      admins.map(admin =>
        this.sendNotification(budgetRequest.id, {
          recipientUserId: admin.id,
          recipientEmail: admin.email,
          recipientName: admin.name,
          subject,
          message,
          notificationType: 'REQUEST_SUBMITTED'
        })
      )
    );
  }

  async notifyRequestApproved(budgetRequest: any) {
    const subject = `Budget Request Approved: ${budgetRequest.requestCode}`;
    const message = `
      Your budget request has been approved!
      
      Request Code: ${budgetRequest.requestCode}
      Approved Amount: ${budgetRequest.reservedAmount}
      Approved By: ${budgetRequest.reviewedByName}
      
      View details at: ${process.env.FRONTEND_URL}/budget-requests/${budgetRequest.id}
    `;

    await this.sendNotification(budgetRequest.id, {
      recipientUserId: budgetRequest.requestedBy,
      recipientEmail: budgetRequest.requestedByEmail,
      recipientName: budgetRequest.requestedByName,
      subject,
      message,
      notificationType: 'REQUEST_APPROVED'
    });
  }

  async notifyRequestRejected(budgetRequest: any) {
    const subject = `Budget Request Rejected: ${budgetRequest.requestCode}`;
    const message = `
      Your budget request has been rejected.
      
      Request Code: ${budgetRequest.requestCode}
      Rejected By: ${budgetRequest.reviewedByName}
      Reason: ${budgetRequest.reviewNotes}
      
      View details at: ${process.env.FRONTEND_URL}/budget-requests/${budgetRequest.id}
    `;

    await this.sendNotification(budgetRequest.id, {
      recipientUserId: budgetRequest.requestedBy,
      recipientEmail: budgetRequest.requestedByEmail,
      recipientName: budgetRequest.requestedByName,
      subject,
      message,
      notificationType: 'REQUEST_REJECTED'
    });
  }

  private async sendNotification(budgetRequestId: number, data: any) {
    try {
      // Save notification to database
      const notification = await prisma.budgetRequestNotification.create({
        data: {
          budgetRequestId,
          ...data,
          deliveryStatus: 'pending'
        }
      });

      // Send email if email provided
      if (data.recipientEmail) {
        await transporter.sendMail({
          from: process.env.SMTP_FROM || 'noreply@buscompany.com',
          to: data.recipientEmail,
          subject: data.subject,
          text: data.message
        });

        // Update delivery status
        await prisma.budgetRequestNotification.update({
          where: { id: notification.id },
          data: {
            sentAt: new Date(),
            deliveryStatus: 'sent'
          }
        });
      }
    } catch (error) {
      console.error('Notification failed:', error);
      
      // Update failure status
      await prisma.budgetRequestNotification.update({
        where: { id: notification.id },
        data: {
          deliveryStatus: 'failed',
          deliveryError: error.message
        }
      });
    }
  }

  private async getDepartmentAdmins(department: string) {
    // This would query your user management system
    // For now, return mock data
    return [
      {
        id: 'admin1',
        email: 'finance.admin@buscompany.com',
        name: 'Finance Admin'
      }
    ];
  }
}

export default new NotificationService();
```

---

## 🧪 Testing Strategy

```typescript
// tests/integration/budgetRequest.test.ts
import request from 'supertest';
import app from '../../src/app';
import { prisma } from '../../src/config/database';

describe('Budget Request API', () => {
  let authToken: string;
  let testBudgetRequestId: number;

  beforeAll(async () => {
    // Setup test database
    await prisma.$executeRaw`TRUNCATE TABLE "BudgetRequest" CASCADE`;
    
    // Get auth token (mock or from auth service)
    authToken = 'test_jwt_token';
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('POST /api/budget-requests', () => {
    it('should create a new budget request', async () => {
      const response = await request(app)
        .post('/api/budget-requests')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          department: 'finance',
          amountRequested: 50000,
          purpose: 'Office equipment upgrade',
          justification: 'Current equipment is outdated',
          category: 'capital',
          priority: 'medium'
        });

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data).toHaveProperty('requestCode');

      testBudgetRequestId = response.body.data.id;
    });

    it('should reject request without required fields', async () => {
      const response = await request(app)
        .post('/api/budget-requests')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          department: 'finance'
          // Missing amountRequested and purpose
        });

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });
  });

  describe('GET /api/budget-requests', () => {
    it('should list budget requests with pagination', async () => {
      const response = await request(app)
        .get('/api/budget-requests')
        .set('Authorization', `Bearer ${authToken}`)
        .query({ page: 1, limit: 10 });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body).toHaveProperty('meta');
      expect(response.body.meta).toHaveProperty('page');
      expect(response.body.meta).toHaveProperty('total');
    });
  });

  describe('POST /api/budget-requests/:id/approve', () => {
    it('should approve budget request (admin only)', async () => {
      const response = await request(app)
        .post(`/api/budget-requests/${testBudgetRequestId}/approve`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          reviewNotes: 'Approved for Q4 allocation',
          reservedAmount: 52500,
          bufferPercentage: 5
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.status).toBe('APPROVED');
    });
  });
});
```

---

## 📚 Documentation & Best Practices

### API Documentation Structure

```markdown
# Budget Request Creation API Documentation

## Base URL
`http://localhost:4005/api`

## Authentication
All endpoints require JWT token in Authorization header:
```
Authorization: Bearer <jwt_token>
```

## Endpoints

### Create Budget Request
**POST** `/budget-requests`

Creates a new budget request.

**Request Body:**
```json
{
  "department": "finance",
  "amountRequested": 50000,
  "purpose": "Office equipment upgrade",
  "justification": "Detailed justification here",
  "category": "capital",
  "priority": "high",
  "items": [
    {
      "itemName": "Laptops",
      "quantity": 10,
```json
      "unitCost": 45000,
      "totalCost": 450000,
      "supplierId": "SUP-001",
      "supplierName": "Tech Solutions Inc.",
      "itemPriority": "must_have",
      "isEssential": true
    }
  ]
}
```

**Response (201 Created):**
```json
{
  "success": true,
  "message": "Budget request created successfully",
  "data": {
    "id": 1,
    "requestCode": "BR-2025-001",
    "department": "finance",
    "amountRequested": 50000,
    "status": "PENDING",
    "isDraft": true,
    "createdAt": "2025-10-23T10:30:00Z"
  }
}
```

### List Budget Requests
**GET** `/budget-requests`

Retrieves paginated list of budget requests with filters.

**Query Parameters:**
- `page` (number): Page number (default: 1)
- `limit` (number): Items per page (default: 20, max: 100)
- `status` (string): Filter by status (PENDING, APPROVED, REJECTED)
- `department` (string): Filter by department
- `dateFrom` (string): Start date (YYYY-MM-DD)
- `dateTo` (string): End date (YYYY-MM-DD)
- `priority` (string): Filter by priority

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Budget requests retrieved successfully",
  "data": [...],
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "totalPages": 8
  }
}
```
```

---

## 🔒 Security Best Practices

### Input Validation

```typescript
// src/utils/validation.util.ts
import Joi from 'joi';

export const budgetRequestSchema = Joi.object({
  department: Joi.string()
    .valid('finance', 'hr', 'inventory', 'operations')
    .required(),
  
  amountRequested: Joi.number()
    .positive()
    .max(10000000)
    .required(),
  
  purpose: Joi.string()
    .min(10)
    .max(500)
    .required(),
  
  justification: Joi.string()
    .max(5000)
    .optional(),
  
  category: Joi.string()
    .valid('operational', 'capital', 'administrative', 'emergency')
    .optional(),
  
  priority: Joi.string()
    .valid('low', 'medium', 'high', 'urgent')
    .optional(),
  
  items: Joi.array()
    .items(
      Joi.object({
        itemName: Joi.string().required(),
        quantity: Joi.number().positive().required(),
        unitCost: Joi.number().positive().required(),
        totalCost: Joi.number().positive().required(),
        supplierId: Joi.string().optional(),
        supplierName: Joi.string().optional(),
        itemPriority: Joi.string()
          .valid('must_have', 'should_have', 'nice_to_have')
          .optional(),
        isEssential: Joi.boolean().optional()
      })
    )
    .optional()
});

export function validateBudgetRequest(data: any) {
  return budgetRequestSchema.validate(data, { abortEarly: false });
}
```

### Validation Middleware

```typescript
// src/middlewares/validation.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { validateBudgetRequest } from '../utils/validation.util';

export const validateCreateBudgetRequest = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const { error, value } = validateBudgetRequest(req.body);

  if (error) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message
      }))
    });
  }

  req.body = value;
  next();
};
```

### SQL Injection Prevention

```typescript
// ✅ GOOD: Using Prisma (parameterized queries)
await prisma.budgetRequest.findMany({
  where: {
    department: userInput, // Safe - parameterized
    status: 'PENDING'
  }
});

// ❌ BAD: Raw SQL with string concatenation
await prisma.$queryRaw`
  SELECT * FROM "BudgetRequest" 
  WHERE department = ${userInput}
`; // Still safe with Prisma's tagged template

// ❌ VERY BAD: Direct string interpolation
await prisma.$queryRawUnsafe(
  `SELECT * FROM "BudgetRequest" WHERE department = '${userInput}'`
); // NEVER do this!
```

### XSS Prevention

```typescript
// src/utils/sanitize.util.ts
import sanitizeHtml from 'sanitize-html';

export function sanitizeInput(input: string): string {
  return sanitizeHtml(input, {
    allowedTags: [],
    allowedAttributes: {}
  });
}

export function sanitizeObject(obj: any): any {
  if (typeof obj === 'string') {
    return sanitizeInput(obj);
  }
  
  if (Array.isArray(obj)) {
    return obj.map(item => sanitizeObject(item));
  }
  
  if (obj !== null && typeof obj === 'object') {
    const sanitized: any = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeObject(value);
    }
    return sanitized;
  }
  
  return obj;
}
```

### Rate Limiting

```typescript
// src/middlewares/rateLimit.middleware.ts
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import redis from '../config/redis';

// General API rate limit
export const apiLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:api:'
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requests per window
  message: {
    success: false,
    message: 'Too many requests, please try again later',
    code: 'RATE_LIMIT_EXCEEDED'
  },
  standardHeaders: true,
  legacyHeaders: false
});

// Stricter limit for creation endpoints
export const createLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:create:'
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // 10 creations per window
  message: {
    success: false,
    message: 'Too many creation requests, please slow down',
    code: 'CREATE_LIMIT_EXCEEDED'
  }
});

// Apply in routes
import { apiLimiter, createLimiter } from '../middlewares/rateLimit.middleware';

router.use(apiLimiter); // Apply to all routes
router.post('/', createLimiter, controller.createBudgetRequest); // Extra limit for POST
```

---

## 🚀 Deployment Configuration

### Docker Setup

```dockerfile
# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package.json pnpm-lock.yaml ./

# Install dependencies
RUN npm install -g pnpm && pnpm install --frozen-lockfile

# Copy source code
COPY . .

# Generate Prisma client
RUN pnpm prisma generate

# Build TypeScript
RUN pnpm build

# Production image
FROM node:18-alpine

WORKDIR /app

# Copy built files
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./
COPY --from=builder /app/prisma ./prisma

# Expose port
EXPOSE 4005

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:4005/api/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

# Start application
CMD ["node", "dist/index.js"]
```

### Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  budget-request-api:
    build: .
    container_name: budget-request-microservice
    ports:
      - "4005:4005"
    environment:
      - NODE_ENV=production
      - PORT=4005
      - BUDGET_REQUEST_DATABASE_URL=postgresql://postgres:password@postgres:5432/budget_request_db
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - JWT_SECRET=${JWT_SECRET}
      - FINANCE_API_URL=http://finance-api:4001
      - AUDIT_LOGS_API_URL=http://audit-api:4004
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    networks:
      - microservices

  postgres:
    image: postgres:15-alpine
    container_name: budget-postgres
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=budget_request_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5433:5432"
    networks:
      - microservices

  redis:
    image: redis:7-alpine
    container_name: budget-redis
    ports:
      - "6380:6379"
    volumes:
      - redis_data:/data
    networks:
      - microservices

volumes:
  postgres_data:
  redis_data:

networks:
  microservices:
    external: true
```

### Nginx Reverse Proxy

```nginx
# nginx.conf
upstream budget_request_backend {
    least_conn;
    server budget-request-api:4005 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name budget.buscompany.local;

    # Request size limit
    client_max_body_size 10M;

    # Compression
    gzip on;
    gzip_types application/json;
    gzip_min_length 1000;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # API routes
    location /api/ {
        proxy_pass http://budget_request_backend;
        proxy_http_version 1.1;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;

        # Buffering
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
    }

    # Health check endpoint
    location /health {
        proxy_pass http://budget_request_backend/api/health;
        access_log off;
    }
}
```

---

## 📊 Monitoring & Logging

### Winston Logger Setup

```typescript
// src/config/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'budget-request-microservice' },
  transports: [
    // Write all logs to console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // Write all logs with level 'error' and below to error.log
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    
    // Write all logs to combined.log
    new winston.transports.File({ 
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

export default logger;
```

### Request Logger Middleware

```typescript
// src/middlewares/requestLogger.middleware.ts
import { Request, Response, NextFunction } from 'express';
import logger from '../config/logger';

export const requestLogger = (req: Request, res: Response, next: NextFunction) => {
  const startTime = Date.now();

  // Log request
  logger.info('Incoming request', {
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.get('user-agent'),
    userId: req.user?.id
  });

  // Log response
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    
    const logData = {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userId: req.user?.id
    };

    if (res.statusCode >= 400) {
      logger.error('Request failed', logData);
    } else {
      logger.info('Request completed', logData);
    }
  });

  next();
};
```

### Application Metrics

```typescript
// src/services/metrics.service.ts
import { prisma } from '../config/database';
import redis from '../config/redis';

class MetricsService {
  async getSystemMetrics() {
    const [
      totalRequests,
      pendingRequests,
      approvedRequests,
      rejectedRequests,
      totalReserved,
      cacheHitRate
    ] = await Promise.all([
      prisma.budgetRequest.count(),
      prisma.budgetRequest.count({ where: { status: 'PENDING' } }),
      prisma.budgetRequest.count({ where: { status: 'APPROVED' } }),
      prisma.budgetRequest.count({ where: { status: 'REJECTED' } }),
      prisma.budgetRequest.aggregate({
        where: { isReserved: true },
        _sum: { reservedAmount: true }
      }),
      this.getCacheHitRate()
    ]);

    return {
      requests: {
        total: totalRequests,
        pending: pendingRequests,
        approved: approvedRequests,
        rejected: rejectedRequests,
        approvalRate: totalRequests > 0 
          ? ((approvedRequests / totalRequests) * 100).toFixed(2) 
          : 0
      },
      budget: {
        totalReserved: totalReserved._sum.reservedAmount || 0
      },
      cache: {
        hitRate: cacheHitRate
      }
    };
  }

  private async getCacheHitRate(): Promise<string> {
    try {
      const info = await redis.info('stats');
      const hits = this.extractStat(info, 'keyspace_hits');
      const misses = this.extractStat(info, 'keyspace_misses');
      
      const total = hits + misses;
      if (total === 0) return '0%';
      
      return `${((hits / total) * 100).toFixed(2)}%`;
    } catch (error) {
      return 'N/A';
    }
  }

  private extractStat(info: string, key: string): number {
    const match = info.match(new RegExp(`${key}:(\\d+)`));
    return match ? parseInt(match[1]) : 0;
  }
}

export default new MetricsService();
```

---

## 🔄 Background Jobs & Scheduled Tasks

### Cron Jobs Setup

```typescript
// src/jobs/scheduler.ts
import cron from 'node-cron';
import logger from '../config/logger';
import syncService from '../services/sync.service';
import { prisma } from '../config/database';

export function initializeScheduledJobs() {
  // Sync department budgets every 15 minutes
  cron.schedule('*/15 * * * *', async () => {
    logger.info('Starting scheduled budget sync');
    
    try {
      const departments = ['finance', 'hr', 'inventory', 'operations'];
      const fiscalYear = new Date().getFullYear();
      const fiscalPeriod = getCurrentFiscalPeriod();

      await Promise.allSettled(
        departments.map(dept =>
          syncService.syncDepartmentBudget(dept, fiscalYear, fiscalPeriod)
        )
      );

      logger.info('Budget sync completed');
    } catch (error) {
      logger.error('Budget sync failed', { error });
    }
  });

  // Check for expired reservations daily at midnight
  cron.schedule('0 0 * * *', async () => {
    logger.info('Checking for expired budget reservations');
    
    try {
      const expired = await prisma.budgetRequest.findMany({
        where: {
          isReserved: true,
          isExpired: false,
          reservationExpiry: {
            lt: new Date()
          }
        }
      });

      if (expired.length > 0) {
        await prisma.budgetRequest.updateMany({
          where: {
            id: {
              in: expired.map(br => br.id)
            }
          },
          data: {
            isExpired: true,
            isReserved: false
          }
        });

        logger.info(`Marked ${expired.length} reservations as expired`);
      }
    } catch (error) {
      logger.error('Expiration check failed', { error });
    }
  });

  // Generate daily aggregates at 1 AM
  cron.schedule('0 1 * * *', async () => {
    logger.info('Generating daily aggregates');
    
    try {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      yesterday.setHours(0, 0, 0, 0);

      const stats = await prisma.budgetRequest.groupBy({
        by: ['department', 'status'],
        where: {
          createdAt: {
            gte: yesterday,
            lt: new Date(yesterday.getTime() + 24 * 60 * 60 * 1000)
          }
        },
        _count: true,
        _sum: {
          amountRequested: true,
          reservedAmount: true
        }
      });

      logger.info('Daily aggregates generated', { stats });
    } catch (error) {
      logger.error('Aggregation failed', { error });
    }
  });

  logger.info('✅ Scheduled jobs initialized');
}

function getCurrentFiscalPeriod(): string {
  const now = new Date();
  const month = now.getMonth() + 1;
  const quarter = Math.ceil(month / 3);
  return `Q${quarter}`;
}
```

### Job Initialization

```typescript
// src/index.ts
import express from 'express';
import { initializeScheduledJobs } from './jobs/scheduler';
import logger from './config/logger';

const app = express();

// ... middleware setup ...

// Initialize scheduled jobs
if (process.env.NODE_ENV !== 'test') {
  initializeScheduledJobs();
}

const PORT = process.env.PORT || 4005;

app.listen(PORT, () => {
  logger.info(`✅ Budget Request Microservice running on port ${PORT}`);
});
```

---

## 📖 Quick Start Commands

```bash
# Install dependencies
pnpm install

# Generate Prisma client
pnpm prisma generate

# Run database migrations
pnpm prisma migrate dev

# Seed database with initial data
pnpm prisma db seed

# Start development server
pnpm dev

# Run tests
pnpm test

# Build for production
pnpm build

# Start production server
pnpm start

# Docker commands
docker-compose up -d          # Start all services
docker-compose logs -f        # View logs
docker-compose down           # Stop all services
docker-compose down -v        # Stop and remove volumes
```

---

## 🎯 Summary Checklist

### Core Features
- ✅ JWT authentication with role-based access control
- ✅ API key authentication for inter-service communication
- ✅ Multi-item budget request support
- ✅ Item-level allocation tracking
- ✅ Approval workflow with history
- ✅ Budget sync with Finance Main system
- ✅ Audit logging integration
- ✅ Webhook events for real-time notifications
- ✅ Email notifications
- ✅ Redis caching for performance

### Optimizations
- ✅ Database indexes on critical fields
- ✅ Redis caching (department budget, request details, permissions)
- ✅ Response caching middleware
- ✅ Cursor-based pagination
- ✅ Batch operations with transactions
- ✅ Rate limiting
- ✅ Connection pooling

### Security
- ✅ Input validation with Joi
- ✅ XSS prevention (sanitization)
- ✅ SQL injection prevention (Prisma ORM)
- ✅ API key hashing (SHA-256)
- ✅ JWT signature verification
- ✅ CORS configuration
- ✅ Security headers (Nginx)

### Monitoring
- ✅ Structured logging (Winston)
- ✅ Request/response logging
- ✅ Error tracking
- ✅ Application metrics
- ✅ Health check endpoint
- ✅ Cache hit rate monitoring

### Integration
- ✅ Finance Main API integration
- ✅ Audit Logs API integration
- ✅ Webhook system for events
- ✅ Scheduled sync jobs
- ✅ Graceful error handling

### DevOps
- ✅ Docker containerization
- ✅ Docker Compose orchestration
- ✅ Nginx reverse proxy
- ✅ Health checks
- ✅ Environment configuration
- ✅ Database migrations
- ✅ Seeding scripts

---

## 🚀 Next Steps

1. **Initialize the project structure** as outlined above
2. **Set up the database** and run migrations
3. **Implement authentication** (JWT + API Key middlewares)
4. **Build core services** (Budget Request CRUD operations)
5. **Integrate with Finance Main** (sync service)
6. **Integrate with Audit Logs** (audit logger service)
7. **Implement caching** (Redis integration)
8. **Add webhooks** (event dispatcher)
9. **Set up notifications** (email service)
10. **Write tests** (unit, integration, e2e)
11. **Configure deployment** (Docker, Nginx)
12. **Set up monitoring** (logging, metrics)
13. **Document API** (OpenAPI/Swagger)

This comprehensive guide provides everything needed to build a production-ready Budget Request Creation Microservice with optimal performance, security, and maintainability. 🎉